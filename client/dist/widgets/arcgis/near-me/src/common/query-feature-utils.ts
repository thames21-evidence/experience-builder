import type Geometry from 'esri/geometry/Geometry'
import type SpatialReference from 'esri/geometry/SpatialReference'
import { type FeatureLayerQueryParams, type DataRecord, utils } from 'jimu-core'

/**
 * Returns all the records satisfying the query
 * If the number of records are more than the maxRecord count then all the records are fetched by batch query and finally all records are return
 * @param ds Layers DataSource from which records needs to be fetched
 * @param queryGeometry Geometry of the buffer/ the incident location
 * @param returnGeometry Specify if geometry should returned while fetching the records
 * @param outSR Out Spatial Reference in which the returned geometries should be
 * @param outFields use datasources out fields
 * @returns promise of dataRecords
 */
export const getALLFeatures = async (ds, queryGeometry: Geometry, returnGeometry: boolean, outSR: SpatialReference, outFields: string[], signal?: AbortSignal): Promise<DataRecord[]> => {
  const promise = new Promise<DataRecord[]>((resolve) => {
    if (!ds) {
      resolve([])
      return
    }
    let outFieldsArr
    if (outFields === undefined) {
      outFieldsArr = ['*']
    } else {
      //skip esriCTApproxDistance as this is a custom field generated by widget which will not be available for query
      outFieldsArr = Object.assign([], outFields)
      if (outFields?.includes('esriCTApproxDistance')) {
        outFieldsArr.splice(outFields.indexOf('esriCTApproxDistance'), 1)
      }
    }
    //To prevent query errors, filter out any fields that are not present in the data source's schema.
    const fieldsInSchema = ds.getSchema()?.fields
    if (fieldsInSchema) {
      const fieldsInDS = Object.keys(fieldsInSchema).map(key => key.toLowerCase())
      outFieldsArr = outFieldsArr.filter(field => fieldsInDS.includes(field.toLowerCase()))
    }
    //if the objectId field is not available in the outfields then add the objectId field in outfields array
    const oid = ds.getIdField()
    if (oid && !outFieldsArr.includes('*') && !outFieldsArr.includes(oid)) {
      outFieldsArr.push(oid)
    }
    const query: FeatureLayerQueryParams = {}
    if (queryGeometry) {
      //when passing query as FeatureLayerQueryParams use toJson else invalid geometry is passed in the query request
      query.geometry = queryGeometry.toJSON()
      query.geometryType = queryGeometry ? utils.getGeometryType(queryGeometry) : undefined
    }
    //get all the fields as we need to show the feature info
    query.outFields = outFieldsArr
    //get the return geometry only if asked
    query.returnGeometry = returnGeometry
    query.notAddFieldsToClient = true
    ds.queryAll(query, signal, null, { excludeQuery: { widgetId: 'filter-data-record-action', dataSourceId: ds.id } }).then((result) => {
      if (signal.aborted) {
        console.error(signal.reason)
        resolve([])
      } else if (result?.records) {
        resolve(result.records)
      } else {
        resolve([])
      }
    }, (err) => {
      console.log(err)
      resolve([])
    })
  })
  return promise
}
