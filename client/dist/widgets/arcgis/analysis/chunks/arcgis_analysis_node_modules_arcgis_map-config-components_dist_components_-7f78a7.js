/*! For license information please see arcgis_analysis_node_modules_arcgis_map-config-components_dist_components_-7f78a7.js.LICENSE.txt */
"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([["extensions_widgets_arcgis_analysis_node_modules_arcgis_map-config-components_dist_components_-7f78a7"],{20551:(e,t,a)=>{a.r(t),a.d(t,{ArcgisMapConfigSmartMappingModalArcade:()=>A});var n=a(73679),i=a(4395),r=a(73801),s=a(5294),l=a(18423),o=a(91813),d=a(21255),u=a(77462),f=a(23054),c=a(49403),m=a(63438),p=a(43786),h=a(83368),g=a(1225),P=(a(54312),a(44345),a(55448),a(52797),a(34031)),y=a(5933),E=(a(28927),a(89704),a(96086),a(13078),a(21303),a(12627),a(56451),a(31521),a(5077),a(23795),a(17902),a(87420),a(30161),a(81734),a(75698),a(10628),a(59640),a(64451),a(6176),a(83552),a(10281),a(83930),a(66617),a(10454),a(29614),a(94916),a(52554),a(2156),a(4038),a(49851),a(75054),a(15223),a(70169),a(47207),a(70852),a(48103),a(39423),a(85681),a(18444),a(42411),a(9767),a(38218),a(91914),a(86605),a(68196),a(440),a(46547),a(6238),a(7299),a(66228)),T=a(71384);async function _(e){const{oneFeatureResponse:t,oneFeatureResponseStatus:a}=e;if(t&&a!==g.s.MISSING)return e.oneFeatureResponse;{const t=await async function(e){const{mapView:t,layer:a,mapImageSublayer:n}=e;if(!("fields"in a))throw new Error("getOneFeature: wrong layer type");if(n)return await w(e);const i="subtype-sublayer"===a.type?a.parent:a;return await t.whenLayerView(i).then(async t=>{const n=t;if("feature"===a.type&&!a.url||"wfs"===a.type){const t=a.createQuery();return t.start=0,t.num=5,t.outFields=["*"],await a.queryFeatures(t).then(async t=>t.features?.length?t:F(e))}{const t="hasM"in a&&a.hasM,i="hasZ"in a&&a.hasZ,r=n.availableFields.length===a.fields?.length&&!t&&!i;if("createQuery"in a&&r){const t=a.createQuery();return t.start=0,t.num=5,t.outFields=["*"],await n.queryFeatures(t).then(async t=>t.features?.length?t:await w(e))}return await w(e)}})}(e);return e.oneFeatureResponse=t?.features.length&&t,e.oneFeatureResponseStatus=t?.features.length?g.s.SUCCESS:g.s.FAILED,t}}async function w(e){const{layer:t,mapView:a}=e;if(!("queryFeatures"in t))return F(e);const n=new P.default({outFields:["*"],where:"1=1",outSpatialReference:a.spatialReference,returnGeometry:!0,returnM:"hasM"in t&&t.hasM,returnZ:"hasZ"in t&&t.hasZ});return"sourceJSON"in t&&t.sourceJSON?.advancedQueryCapabilities?.supportsPagination&&(n.num=1),await t.queryFeatures(n).catch(F)}function F(e){const{layer:t}=e,a={};"fields"in t&&t.fields?.forEach(e=>{e.defaultValue?a[e.name]=e.defaultValue:["small-integer","big-integer","integer","single","double","long","date","oid"].includes(e.type)?a[e.name]=0:"date-only"===e.type?a[e.name]=null:a[e.name]=""});const n=new m.default({geometry:void 0,symbol:void 0,attributes:a});return new y.default({features:[n],fields:[],geometryType:(0,g.j)(e),spatialReference:"spatialReference"in t?t.spatialReference.clone():void 0})}class A extends r.WF{constructor(){super(...arguments),this.allowConfigureTimeSeries=!1,this.arcgisClose=(0,r.lh)()}static{this.properties={fieldInfo:0,allowConfigureTimeSeries:5,smartMappingState:0}}static{this.shadowRootOptions=r.Iq}async load(){this.testData=await this.getArcadeTestData(this.smartMappingState)}getArcadeProfile(e){const{layer:t,useFeatureReduction:a}=e;return{id:"visualization",definitions:{$feature:a?{fields:(0,E.d)(t.featureReduction.popupTemplate)}:t}}}async getArcadeTestData(e){const{layer:t,mapView:a,useFeatureReduction:n}=e;return{profileVariableInstances:{$feature:n?await(0,E.e)(a,t,t.featureReduction.popupTemplate):await this.getOneArcadeFeature(e),$view:{scale:a.scale,timeProperties:a.timeExtent?{currentStart:a.timeExtent.start,currentEnd:a.timeExtent.end,startIncluded:!0,endIncluded:!0}:void 0}},spatialReference:a.spatialReference}}async getOneArcadeFeature(e){const{layer:t,mapView:a}=e;let n;if(!("fields"in t))return null;{await _(e);const{oneFeatureResponse:i}=e;if(i?.features?.length)n=s.clone(i.features[0]);else{const i={};t.fields?.forEach(e=>{["small-integer","big-integer","integer","single","double","string","date","date-only","oid","guid"].includes(e.type)&&!1===e.nullable?e.defaultValue?i[e.name]=e.defaultValue:"string"===e.type?i[e.name]="":i[e.name]=0:i[e.name]=null});const r=a.extent;let s,h;(0,g.o)(e)?(s=new d.default({spatialReference:new p.default(a.spatialReference.toJSON())}),s.addRing([[r.xmin,r.ymin],[r.xmax,r.ymin],[r.xmax,r.ymax],[r.xmin,r.ymax],[r.xmin,r.ymin]]),h=new u.default):(0,g.m)(e)?(s=new l.default(r.center.toJSON()),h=new f.default):(0,g.n)(e)&&(s=new o.default({spatialReference:new p.default(a.spatialReference.toJSON())}),s.addPath([[r.xmin,r.ymin],[r.xmax,r.ymax]]),h=new c.default),n=new m.default({geometry:s,symbol:h,attributes:i})}}return n}render(){const{fieldInfo:e,allowConfigureTimeSeries:t,testData:a,smartMappingState:n}=this,{layer:r,portal:s,_messages:l,mapImageSublayer:o,allowTimeSeriesConfiguration:d,fields:u,useFeatureReduction:f}=n,c=r;let m,p;return d&&!o&&(m=[{label:l.arcade.suggestions,suggestions:[{label:l.arcade.timeSeries,description:l.arcade.timeSeriesDescription,code:(0,T.g)({resultFormatPattern:""})}]}],t&&(p={fields:u.map(e=>e.layerField),useFeatureReduction:!!f})),i.qy`<arcgis-map-config-modal-arcade .arcadeScript=${e?.expression||""} .arcadeProfile=${this.getArcadeProfile(n)} .testData=${a} add-existing-expressions .layer=${c} .portal=${s} .arcadeTitle=${e?.expressionTitle||l.arcade.newExpression} arcade-title-editable .arcadeTitleEditingEnabled=${!e?.expressionTitle} return-predict-output-type .suggestions=${m} .timeSeriesProps=${p} @arcgisClose=${async e=>{if(e.stopPropagation(),!e.detail)return void this.arcgisClose.emit();const{script:t,title:a,predictOutputType:i,timeSeriesInfo:r}=e.detail;if(!t?.trim().length)return void this.arcgisClose.emit();const s=await h.getExpressionFields(c,[t]);(0,g.a0)(n,s),this.arcgisClose.emit({expression:t,expressionTitle:a,simpleFieldType:t.includes(T.a)?g.J.UNKNOWN:"number"===i?g.J.NUMBER:"string"===i?g.J.STRING:"date"===i?g.J.NUMBER:g.J.UNKNOWN,...r&&{timeSeriesInfo:r}})}}></arcgis-map-config-modal-arcade>`}}(0,n.c)("arcgis-map-config-smart-mapping-modal-arcade",A)},71384:(e,t,a)=>{a.d(t,{a:()=>n,g:()=>i});const n="timeProperties";function i(e){return`// To configure a time series visualization using this template, data for this layer should be structured so that\n// each row represents a static feature with a fixed location, such as a country boundary or a city location.\n// The attribute table should have two or more fields that represent the same data attributes at different points in time for each feature.\n// Field names should refer to a specific attribute and a specific point in time, such as population in a specific year.\n// e.g. POP1990, POP2000, POP2010, POP2020, POP2030\n\n// There are four areas of this template where modification is necessary for the template to work with your layer\n// Two are required, and two are optional. \n\n// Examine your data and the details below to edit the template accordingly.\n\nvar FIELD_NAME_PATTERN = "POP{Y}"; // Required - Update this to match your data. See Lines 17-49 for details.\nExpects($feature, "POP*"); // Required - Update this to match your data. See Lines 51-63 for details.\nvar DEFAULT_FIELD_NAME = ""; // Optional - See Lines 65-79 for details.\nvar RESULT_FORMAT_PATTERN = "${e?.resultFormatPattern??"#,###.00"}"; // Optional - Update this to match your data. See Lines 81-93 for details.\n\n// FIELD_NAME_PATTERN\n//\n// The field name pattern is used to create the field name from the time slider values.\n// Patterns are defined using the following syntax: fieldName{pattern}\n//\n// EXAMPLE 1: given fields with names Cases_2023_10_01, Cases_2023_10_02, Cases_2023_10_03, etc., the field name pattern would be:\n// var FIELD_NAME_PATTERN = "Cases_{Y_MM_DD}";\n//\n// EXAMPLE 2: given fields with names POP2000, POP2010, POP2020, etc., the field name pattern would be:\n// var FIELD_NAME_PATTERN = "POP{Y}";\n//\n// The following patterns are supported:\n//\n// D: Day of the month, not padded (1 - 31)\n// DD: Day of the month, padded (01 - 31)\n// DDD: Ordinal day of the year (1 - 365)\n// d: Day of the week (1 - 7)\n// ddd: Abbreviated day of the week (e.g. Mon)\n// dddd: Full day of the week (e.g. Monday)\n// M: Month number (1 - 12)\n// MM: Month number, padded (01 - 12)\n// MMM: Abbreviated month name (e.g. Jan)\n// MMMM: Full month name (e.g. January)\n// Y: Full year\n// YY: Two-digit year\n// h: Civilian hours, not padded (1 - 12)\n// hh: Civilian hours, padded (01 - 12)\n// H: Military hours, not padded (0 - 23)\n// HH: Military hours, padded (00 - 23)\n// m: Minutes, not padded (0 - 59)\n// mm: Minutes, padded (00 - 59)\n// s: Seconds, not padded (0 - 59)\n// ss: Seconds, padded (00 - 59)\n\n// EXPECTS\n//\n// Copy and paste the part of the field pattern common to all fields\n// followed by an asterisk (*) into the second parameter of the Expects function.\n// This must be a raw text value like "POP*", not a variable name like FIELD_NAME_PATTERN.\n// \n// EXAMPLE 1: given fields with names Cases_2023_10_01, Cases_2023_10_02, Cases_2023_10_03, etc.\n//   - Expects($feature, \u201cCases_*\u201d);  // includes all fields that start with "Cases_"\n//   - Expects($feature, \u201cCases_2023*\u201d); // includes all Cases fields for the year 2023\n// \n// EXAMPLE 2: given fields with names POP2000, POP2010, POP2020, etc.\n//   - Expects($feature, "POP*"); // includes all fields that start with "POP"\n//   - Expects($feature, "POP2*"); // includes all "POP" fields for all years after 2000\n\n// DEFAULT_FIELD_NAME\n//\n// The field name to return if the time slider is closed.\n// Suggested values might include the first field in the time series,\n// the most recent field in the time series, or possibly an\n// aggregated value, such as TOTAL_POPULATION.\n// \n// EXAMPLE 1: The first field in the time series. Given fields with names POP2000, POP2010, POP2020, TOTAL_POPULATION,\n// var DEFAULT_FIELD_NAME = "POP2000";\n//\n// EXAMPLE 2: An aggregated value such as the total population. Given fields with names POP2000, POP2010, POP2020, TOTAL_POPULATION,\n// var DEFAULT_FIELD_NAME = "TOTAL_POPULATION";\n//\n// Note - If you defined a default field, be sure to include it in the Expects function as a third parameter.\n// e.g. Expects($feature, "POP*", "TOTAL_POPULATION");\n\n// RESULT_FORMAT_PATTERN\n//\n// The result format pattern is used to format the result of the calculation.\n// Patterns are defined using the following syntax: #,###.00\n// This should only be defined for formatting numeric values in labels or popups.\n// If using for symbology/layer styles, or the field data type\n// is a string, then leave this value empty.\n//\n// EXAMPLE 1: if returning a numeric value in a label,\n// var RESULT_FORMAT_PATTERN = "#,###"; // formats the value with commas and rounded to nearest integer\n// \n// EXAMPLE 2: if returning a numeric value in a popup,\n// var RESULT_FORMAT_PATTERN = "#,###.00"; // formats the value with commas and two decimal places\n\nfunction fieldsWithPatternFilter(field) {\n  var prefix = Front(Split(FIELD_NAME_PATTERN, "{"));\n  var suffix = Back(Split(FIELD_NAME_PATTERN, "}"));\n  var patternToFind = DefaultValue(prefix, suffix);\n  return Find(patternToFind, field.name) > -1;\n}\n\nfunction fieldsWithPatternMap(field) {\n  return field.name;\n}\n\nfunction getAllFieldsFromPattern() {\n  var fields = Schema($feature).fields;\n  return Sort(\n    Map(Filter(fields, fieldsWithPatternFilter), fieldsWithPatternMap)\n  );\n}\n\nfunction getFieldNameFromTimeProperties(dateValue, pattern) {\n  var fieldName = pattern;\n\n  var startPosition = Find("{", fieldName);\n  while (startPosition > -1) {\n    var startIndex = Find("{", fieldName, startPosition);\n    var endIndex = Find("}", fieldName, startIndex);\n    var searchText = Mid(fieldName, startIndex, endIndex - startIndex + 1);\n    var dateText = Text(dateValue, searchText);\n    fieldName = Replace(fieldName, searchText, dateText);\n    startPosition = Find("{", fieldName, endIndex);\n  }\n  fieldName = Replace(Replace(fieldName, "{", ""), "}", "");\n  return fieldName;\n}\n\nvar hasCurrentStart = HasValue($view, ["timeProperties", "currentStart"]);\nvar hasCurrentEnd = HasValue($view, ["timeProperties", "currentEnd"]);\n\nvar hasTimeProperties = hasCurrentStart || hasCurrentEnd;\n\nif (!hasTimeProperties) {\n  if (!IsEmpty(DEFAULT_FIELD_NAME) && HasKey($feature, DEFAULT_FIELD_NAME)) {\n    return $feature[DEFAULT_FIELD_NAME];\n  }\n  var firstField = Front(getAllFieldsFromPattern());\n  return $feature[firstField];\n}\n\nvar currentValue = DefaultValue(\n  $view.timeProperties.currentEnd,\n  $view.timeProperties.currentStart\n);\n\nfunction getValueAtInstant() {\n  var fieldName = getFieldNameFromTimeProperties(\n    currentValue,\n    FIELD_NAME_PATTERN\n  );\n  if (HasValue($feature, fieldName)) {\n    var value = $feature[fieldName];\n    return value;\n  }\n  return null;\n}\n\nfunction formatResult(value) {\n  if (IsEmpty(value)) {\n    return null;\n  }\n  if (IsEmpty(RESULT_FORMAT_PATTERN)) {\n    return value;\n  }\n  return Text(value, RESULT_FORMAT_PATTERN);\n}\n\nvar result = getValueAtInstant();\nreturn formatResult(result);`}}}]);